#!/usr/bin/perl
use strict;
use warnings;
use FindBin;
use lib "$FindBin::Bin/../lib";
use Getopt::Long;
use WR::Daemon::Process;
use Mojo::Log;
use WR::Statterpush::Server;
use Mojo::JSON;
use Time::HiRes;
use Time::HiRes;
use Time::HiRes;
use Time::HiRes;
use POSIX ":sys_wait_h";

my $config      = {};
my $cfile       = undef;
my $daemon      = undef;
my $workers     = 4;
my $stopping    = 0;
my $max         = 32;
my $skip_wn7    = 0;
my $ls          = undef;

$SIG{TERM} = sub {
    $stopping = 1;
};

$SIG{KILL} = sub {
    $stopping = 1;
};

my $children    = {};
my $child_count = 0;

GetOptions(
    'config=s'      => \$cfile,
    'workers|w=i'   => \$workers,
    'max|m=i'       => \$max,
    'log-stdout!'   => \$ls,
);

die 'Usage: ', $0, ' --config <path to config file> --workers <worker count> --max <max to process>', "\n" unless(defined($cfile));

my $craw = '';
if(my $fh = IO::File->new($cfile)) {
    $craw .= $_ while(<$fh>);
    $fh->close;

    $config = eval($craw);

    die 'Error parsing configuration: ', $@, "\n" if($@);
} else {
    die 'Could not open configuration file "', $cfile, '": ', $!, "\n";
}

my $mango       = Mango->new($config->{mongodb}->{host});
my $db          = $mango->db($config->{mongodb}->{database});

sub get_push { return WR::Statterpush::Server->new(host => 'api.statterbox.com', token => $config->{statterbox}->{server}, group => 'wotreplays') };

my $log;
if(my $lf = $config->{processd}->{logfile} && !$ls) {
    $lf = sprintf('%s/../%s', $FindBin::Bin, $config->{processd}->{logfile}) if($lf !~ /^\//);
    $log = Mojo::Log->new(path => $lf, level => $config->{processd}->{loglevel} || 'warn');
} else {
    $log = Mojo::Log->new(level => 'debug');
}

# create a pidfile
my $pidfile = $config->{processd}->{pidfile};
if(my $fh = IO::File->new(sprintf('>%s', $pidfile))) {
    $fh->print($$);
    $fh->close;
} else {
    die 'Could not create pidfile: ', $!, "\n";
}

sub _log {
    my $l = shift;
    my $m = join('', '[master][', $$, ']: ', @_);
    $log->$l($m);
}
sub debug   { _log('debug', @_) }
sub info    { _log('info', @_) }
sub error   { _log('error', @_) }

info('processd started');

sub REAPER_OF_DEAD_KIDLETS {
    my $child;
    while (($child = waitpid(-1, WNOHANG)) > 0) {
        delete($children->{$child});
        $child_count--;
        debug('reaped ', $child, ' count now ', $child_count);
    }
    $SIG{CHLD} = \&REAPER_OF_DEAD_KIDLETS;
}
$SIG{CHLD} = \&REAPER_OF_DEAD_KIDLETS;

sub get_jobs {
    my $limit = shift;
    my $cursor = $db->collection('jobs')->find({
        ready       => Mango::BSON::bson_true,
        complete    => Mango::BSON::bson_false,
    });
    my $total = $cursor->count;

    $skip_wn7 = 1 if($total > $max); 
    
    $cursor->sort(Mango::BSON::bson_doc({ priority => 1, ctime => 1 }))->limit($limit);

    return $cursor->all;
}

sub max_spawnable {
    return $workers - $child_count;
}

while(!$stopping) {
    if(my $can_spawn = max_spawnable) {
        my $jobs = ($can_spawn > 0) ? get_jobs($can_spawn) : [];
        debug('can spawn ', $can_spawn, ', got ' . scalar(@$jobs) . ' jobs');
        if(scalar(@$jobs) > 0) {
            while(max_spawnable > 0 && scalar(@$jobs) > 0) {
                my $job = shift(@$jobs);
                next if($job->{locked}); # this may cause issues if we terminate the script because the lock status isn't cleared
                next if(!defined($job->{data}));
                next if(!defined($job->{data}->{file}));
                my $pid = fork();
                if(!defined($pid)) {
                    debug('Could not fork a child: ' . $!);
                } else {
                    if($pid > 0) {
                        $child_count++;
                        $children->{$pid}++; # yais
                        debug('Spawned a child, current count: ', $child_count);
                        debug('job count: ', scalar(@$jobs));
                    } else {
                        # child process
                        my $p = WR::Daemon::Process->new(log => $log, config => $config, skip_wn7 => $skip_wn7);
                        if(defined($job->{type}) && $job->{type} eq 'chatreader') {
                            # ignore the job for the time being, we'll ditch it afterwards anyway
                            $p->db->collection('jobs')->update({ _id => $job->{_id} }, { '$set' => { 'status_text' => [], locked => Mango::BSON::bson_true, locked_by => $$, locked_at => Mango::BSON::bson_time } } );
                            $p->on('message' => sub {
                                my ($p, $text) = (@_);
                                get_push->send_to_channel('admin' => Mojo::JSON->new->encode({ evt => 'chatreader.message', data => { session => $job->{channel}, text => $text } }));
                            });
                            $p->on('finished' => sub {
                                get_push->send_to_channel('admin' => Mojo::JSON->new->encode({ evt => 'chatreader.finished', data => { session => $job->{channel} } }));
                            });
                           $p->process_chatreader($job);
                        } else {
                            $p->db->collection('jobs')->update({ _id => $job->{_id} }, { '$set' => { 'status_text' => [], locked => Mango::BSON::bson_true, locked_by => $$, locked_at => Mango::BSON::bson_time } } );
                            if(my $r = $p->process_job($job)) {
                                if($r->{site}->{visible}) {
                                    get_push->send_to_channel('site' => Mojo::JSON->new->encode({ evt => 'replay.processed', data => { url => sprintf('%s/replay/%s.html', $config->{urls}->{app}, $r->{_id} . '') } }));
                                }
                            }
                        }
                        exit(0); # heuuuh
                    }
                }
            }
        }
    } else {
        debug(q|can't spawn any more children, current count |, $child_count, ' out of ', $workers);
    }
    # sleep for a while
    debug('sleeping 5');
    sleep(5);
}
