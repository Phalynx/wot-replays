#!/usr/bin/perl
use strict;
use warnings;
use FindBin;
use lib "$FindBin::Bin/../lib";
use Getopt::Long;
use Mojo::Log;
use Mango;
use Mango::BSON;
use WR;
use WR::Process::Offline;
use Data::Dumper;
use Carp qw/cluck/;

my $config  = {};
my $cfile   = undef;
my $stopping = 0;

$SIG{TERM} = sub {
    $stopping = 1;
};

$SIG{KILL} = sub {
    $stopping = 1;
};

GetOptions(
    'config=s'      => \$cfile,
);

die 'Usage: ', $0, ' --config <path to config file>', "\n" unless(defined($cfile));

my $craw = '';
if(my $fh = IO::File->new($cfile)) {
    $craw .= $_ while(<$fh>);
    $fh->close;

    $config = eval($craw);

    die 'Error parsing configuration: ', $@, "\n" if($@);
} else {
    die 'Could not open configuration file "', $cfile, '": ', $!, "\n";
}

my $log;
if(my $lf = $config->{processd}->{logfile}) {
    $lf = sprintf('%s/../%s', $FindBin::Bin, $config->{processd}->{logfile}) if($lf !~ /^\//);
    $log = Mojo::Log->new(path => $lf, level => $config->{processd}->{loglevel} || 'warn');
} else {
    $log = Mojo::Log->new();
    # level => $config->{processd}->{loglevel} || 'warn');
}

# create a pidfile
my $pidfile = $config->{processd}->{pidfile};
if(my $fh = IO::File->new(sprintf('>%s', $pidfile))) {
    $fh->print($$);
    $fh->close;
} else {
    die 'Could not create pidfile: ', $!, "\n";
}

$log->info('processd starting, pid ' . $$);

my $mango = Mango->new($config->{mongodb}->{host});
my $db    = $mango->db($config->{mongodb}->{database});

sub job_error {
    my $job = shift;
    my $error = shift;

    $db->collection('jobs')->update({ _id => $job->{_id} }, {
        '$set' => {
            complete => Mango::BSON::bson_true,
            status   => -1,
            error    => $error,
        }
    });
}

sub job_status {
    my $job     = shift;
    my $status  = shift;
    my $current;
    my $u = 0;

    $current = $job->{status_text};

    my $new = [];

    foreach my $e (@$current) {
        if($e->{id} eq $status->{id}) {
            push(@$new, $status);
            $u++;
        } else {
            push(@$new, $e);
        }
    }

    push(@$new, $status) unless($u > 0);

    $db->collection('jobs')->update({ _id => $job->{_id} }, {
        '$set' => {
            status_text => $new,
        }
    });

    $job->{status_text} = $new; # wonder if this works...
}


sub process_job {
    my $job = shift;

    my $o = WR::Process::Offline->new(
        bf_key          => join('', map { chr(hex($_)) } (split(/\s/, $config->{wot}->{bf_key}))),
        banner_path     => $config->{paths}->{banners},
        packet_path     => $config->{paths}->{packets},
        mango           => $mango,
        file            => $job->{data}->{file},
        log             => $log,
        );

    $o->on('state.prepare.start' => sub {
        job_status($job, {
            id      =>  'prepare',
            text    =>  'Preparing replay',
            type    =>  'spinner',
            done    =>  Mango::BSON::bson_false,
        });
    });
    $o->on('state.prepare.finish' => sub {
        job_status($job, {
            id      =>  'prepare',
            text    =>  'Preparing replay',
            type    =>  'spinner',
            done    =>  Mango::BSON::bson_true,
        });
    });
    $o->on('state.streaming.start' => sub {
        my ($o, $total) = (@_);

        job_status($job, {
            id      =>  'streaming',
            text    =>  'Extracting packets',
            type    =>  'progress',
            count   =>  0,
            total   =>  $total,
            perc    =>  0,
            done    =>  Mango::BSON::bson_false,
        });
    });
    $o->on('state.streaming.progress' => sub {
        my ($o, $d) = (@_);
        my $perc;

        if($d->{count} > 0 && $d->{total} > 0) {
            $perc = sprintf('%.0f', (100/($d->{total}/$d->{count})));
        } else {
            $perc = 0;
        }

        job_status($job, {
            id      =>  'streaming',
            text    =>  'Extracting packets',
            type    =>  'progress',
            count   =>  $d->{count},
            total   =>  $d->{total},
            perc    =>  $perc,
            done    =>  Mango::BSON::bson_false,
        });
    });
    $o->on('state.streaming.finish' => sub {
        my ($o, $total) = (@_);
        job_status($job, {
            id      =>  'streaming',
            text    =>  'Extracting packets',
            type    =>  'progress',
            count   =>  $total,
            total   =>  $total,
            perc    =>  100,
            done    =>  Mango::BSON::bson_true,
        });
    });
    $o->on('state.generatebanner.start' => sub {
        job_status($job, {
            id      => 'generatebanner',
            text    => 'Generating preview banner',
            type    => 'spinner',
            done    =>  Mango::BSON::bson_false,
        });
    });
    $o->on('state.generatebanner.finish' => sub {
        job_status($job, {
            id      => 'generatebanner',
            text    => 'Generating preview banner',
            type    => 'spinner',
            done    =>  Mango::BSON::bson_true,
        });
    });
    $o->on('state.packet.save.start' => sub {
        job_status($job, {
            id      => 'packetsave',
            text    => 'Storing replay packets to disk',
            type    => 'spinner',
            done    =>  Mango::BSON::bson_false,
        });
    });
    $o->on('state.packet.save.finish' => sub {
        job_status($job, {
            id      => 'packetsave',
            text    => 'Storing replay packets to disk',
            type    => 'spinner',
            done    =>  Mango::BSON::bson_true,
        });
    });
    $o->on('state.wn7.start' => sub {
        my ($o, $total) = (@_);

        job_status($job, {
            id      =>  'wn7',
            text    =>  'Fetching WN7 data from Statterbox',
            type    =>  'progress',
            count   =>  0,
            total   =>  $total,
            perc    =>  0,
            done    =>  Mango::BSON::bson_false,
        });
    });
    $o->on('state.wn7.progress' => sub {
        my ($o, $d) = (@_);
        my $perc;

        if($d->{count} > 0 && $d->{total} > 0) {
            $perc = sprintf('%.0f', (100/($d->{total}/$d->{count})));
        } else {
            $perc = 0;
        }

        job_status($job, {
            id      =>  'wn7',
            text    =>  'Fetching WN7 data from Statterbox',
            type    =>  'progress',
            count   =>  $d->{count},
            total   =>  $d->{total},
            perc    =>  $perc,
            done    =>  Mango::BSON::bson_false,
        });
    });
    $o->on('state.wn7.finish' => sub {
        my ($o, $total) = (@_);
        job_status($job, {
            id      =>  'wn7',
            text    =>  'Fetching WN7 data from Statterbox',
            type    =>  'progress',
            count   =>  $total,
            total   =>  $total,
            perc    =>  100,
            done    =>  Mango::BSON::bson_true,
        });
    });

    if(my $replay = $o->process) {
        $log->debug('no error yet, yay');

        if($job->{reprocess}) {
            my $oreplay = $db->collection('replays')->find_one({ digest => $job->{_id}});
            $replay->{site} = $oreplay->{site};
            $replay->{_id}  = $oreplay->{_id};
        }

        job_status($job, {
            id      =>  'final',
            text    =>  'Saving replay',
            type    =>  'spinner',
            done    =>  Mango::BSON::bson_false,
        });
        
        if(!defined($replay->{game}->{version_numeric}) || (defined($replay->{game}->{version_numeric}) && $replay->{game}->{version_numeric} < $config->{wot}->{min_version})) {
            unlink($job->{file});
            job_error($job, 'That replay is from an older version of World of Tanks which we cannot process...');
        } elsif($replay->{game}->{version_numeric} > $config->{wot}->{version_numeric}) {
            unlink($job->{file});
            job_error($job, 'That replay seems to be coming from the test server, we cannot process those yet...');
        } else {
            if(!$job->{reprocess}) {
                $replay->{digest} = $job->{_id};
                $replay->{site}->{visible} = Mango::BSON::bson_false if($job->{data}->{visible} < 1);
                $replay->{site}->{description} = (defined($job->{data}->{desc}) && length($job->{data}->{desc}) > 0) ? $job->{data}->{desc} : undef;
                $replay->{file} = $job->{data}->{file_base}; 
            }

            # don't bother with the packets, we'll send them out as an event stream later after we store them in the database(?)
            if(my $oid = $mango->db('wot-replays')->collection('replays')->save($replay)) {
                $db->collection('jobs')->update({ _id => $job->{_id} }, {
                    '$set' => {
                        complete => Mango::BSON::bson_true,
                        status   => 1,
                        replayid => $replay->{_id},
                        banner   => $replay->{site}->{banner},
                        file     => $replay->{file},
                    }
                });
                job_status($job, {
                    id      =>  'final',
                    text    =>  'Saving replay',
                    type    =>  'spinner',
                    done    =>  Mango::BSON::bson_true,
                });
            } else {
                job_error($job, 'Error saving replay');
            }
        }
    } else {
        job_error($job, $o->error);
    }
}

sub get_new_job {
    if(my $job = $db->collection('jobs')->find({
        ready       => Mango::BSON::bson_true,
        complete    => Mango::BSON::bson_false,
    })->sort({ priority => 1, ctime => 1 })->next()) {
        if($job->{locked}) {
            $log->debug('Found new job but it has already been locked');
            return undef;
        } else {
            $db->collection('jobs')->update({ _id => $job->{_id} }, { '$set' => { 'status_text' => [], 'locked' => Mango::BSON::bson_true, 'locked_by' => $$ } } );
            $log->debug('Job is a reprocess job for ', $job->{replayid}) if($job->{reprocess});
            return $job;
        }
    } else {
        return undef;
    }
}

sub main_loop {
    while(!$stopping) {
        if(my $job = get_new_job()) {
            $log->debug('received job, dump follows: ', Dumper($job));
            my $count = $db->collection('replays')->find({ digest => $job->{_id} })->count();
            if($count > 0 && !$job->{reprocess}) {
                job_error($job, 'It seems that replay has already been uploaded and processed...');
            } else {
                process_job($job);
            }
            $stopping = 1;
        } else {
            $log->debug('no job, waiting 10 seconds');
            sleep(10);
        }
    }
    exit(1);
}

main_loop;
