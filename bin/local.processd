#!/usr/bin/perl
use strict;
use warnings;
use FindBin;
use lib "$FindBin::Bin/../lib";
use Getopt::Long;
use Mojo::Log;
use Mango;
use Mango::BSON;
use WR;
use WR::Process::Offline;
use Data::Dumper;
use Carp qw/cluck/;

my $config  = {};
my $cfile   = undef;
my $stopping = 0;

$SIG{TERM} = sub {
    $stopping = 1;
};

$SIG{KILL} = sub {
    $stopping = 1;
};

GetOptions(
    'config=s'      => \$cfile,
);

die 'Usage: ', $0, ' --config <path to config file>', "\n" unless(defined($cfile));

my $craw = '';
if(my $fh = IO::File->new($cfile)) {
    $craw .= $_ while(<$fh>);
    $fh->close;

    $config = eval($craw);

    die 'Error parsing configuration: ', $@, "\n" if($@);
} else {
    die 'Could not open configuration file "', $cfile, '": ', $!, "\n";
}

my $log;
if(my $lf = $config->{processd}->{logfile}) {
    $lf = sprintf('%s/../%s', $FindBin::Bin, $config->{processd}->{logfile}) if($lf !~ /^\//);
    $log = Mojo::Log->new(path => $lf, level => $config->{processd}->{loglevel} || 'warn');
} else {
    $log = Mojo::Log->new();
    # level => $config->{processd}->{loglevel} || 'warn');
}

# create a pidfile
my $pidfile = $config->{processd}->{pidfile};
if(my $fh = IO::File->new(sprintf('>%s', $pidfile))) {
    $fh->print($$);
    $fh->close;
} else {
    die 'Could not create pidfile: ', $!, "\n";
}

$log->info('processd starting, pid ' . $$);

my $mango = Mango->new($config->{mongodb}->{host});
my $db    = $mango->db($config->{mongodb}->{database});

sub job_error {
    my $job = shift;
    my $error = shift;

    $db->collection('jobs')->update({ _id => $job->{_id} }, {
        '$set' => {
            complete => Mango::BSON::bson_true,
            status   => -1,
            error    => $error,
        }
    });
}

sub job_status {
    my $job  = shift;
    my $status = shift;

    $db->collection('jobs')->update({ _id => $job->{_id} }, {
        '$push' => {
            status_text => $status,
        }
    });
}

sub process_job {
    my $job = shift;

    my $o = WR::Process::Offline->new(
        bf_key          => join('', map { chr(hex($_)) } (split(/\s/, $config->{wot}->{bf_key}))),
        banner_path     => $config->{paths}->{banners},
        packet_path     => $config->{paths}->{packets},
        mango           => $mango,
        file            => $job->{data}->{file},
        log             => $log,
        );

    $o->on('state.prepare' => sub {
        job_status($job, 'Preparing replay');
    });
    $o->on('state.finish' => sub {
        job_status($job, 'Finished streaming packets');
    });
    $o->on('state.generatebanner' => sub {
        job_status($job, 'Generating preview banner');
    });
    $o->on('state.wotlabsfetch' => sub {
        job_status($job, 'Fetching WN7 for players');
    });
    $o->on('state.done' => sub {
        job_status($job, 'Done procesing replay');
    });
    $o->on('state.streaming' => sub {
        job_status($job, 'Streaming replay packets');
    });
    $o->on('state.packet.save.start' => sub {
        job_status($job, 'Storing replay packets to disk');
    });
    $o->on('state.packet.save.done' => sub {
        job_status($job, 'Stored replay packets');
    });

    if(my $replay = $o->process) {
        $log->debug('no error, yay');
        if(!defined($replay->{game}->{version_numeric}) || (defined($replay->{game}->{version_numeric}) && $replay->{game}->{version_numeric} < $config->{wot}->{min_version})) {
            unlink($job->{file});
            job_error($job, 'That replay is from an older version of World of Tanks which we cannot process');
        } else {
            $replay->{digest} = $job->{_id};
            $replay->{site}->{visible} = Mango::BSON::bson_false if($job->{data}->{visible} < 1);
            $replay->{site}->{description} = (defined($job->{data}->{desc}) && length($job->{data}->{desc}) > 0) ? $job->{data}->{desc} : undef;
            $replay->{file} = $job->{data}->{file_base}; 

            # don't bother with the packets, we'll send them out as an event stream later after we store them in the database(?)
            if(my $oid = $mango->db('wot-replays')->collection('replays')->save($replay)) {
                $db->collection('jobs')->update({ _id => $job->{_id} }, {
                    '$set' => {
                        complete => Mango::BSON::bson_true,
                        status   => 1,
                        replayid => $replay->{_id},
                        banner   => $replay->{site}->{banner},
                        file     => $replay->{file},
                    }
                });
            } else {
                job_error($job, 'Error saving replay');
            }
        }
    } else {
        job_error($job, $o->error);
    }
}

sub get_new_job {

    if(my $job = $db->collection('jobs')->find({
        ready       => Mango::BSON::bson_true,
        complete    => Mango::BSON::bson_false,
    })->sort({ ctime => 1 })->next()) {
        if($job->{locked}) {
            $log->debug('Found new job but it has already been locked');
            return undef;
        } else {
            $db->collection('jobs')->update({ _id => $job->{_id} }, { '$set' => { 'status_text' => [], 'locked' => Mango::BSON::bson_true, 'locked_by' => $$ } } );
            return $job;
        }
    } else {
        return undef;
    }
}

sub main_loop {
    while(!$stopping) {
        if(my $job = get_new_job()) {
            $log->debug('received job, dump follows: ', Dumper($job));
            my $count = $db->collection('replays')->find({ digest => $job->{_id} })->count();
            if($count > 0) {
                job_error($job, 'It seems that replay has already been uploaded and processed...');
            } else {
                process_job($job);
            }
            $stopping = 1;
        } else {
            $log->debug('no job, waiting 10 seconds');
            sleep(10);
        }
    }
    exit(0);
}

main_loop;
